<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">"
<p>Логическая схема перцептрона с тремя выходами</p>
<p><b>Перцептро?н</b>, или <b>пер<i>с</i>ептрон</b> ( от  — восприятие; ) — математическая и компьютерная модель восприятия информации мозгом (кибернетическая <i>модель мозга</i>), предложенная Фрэнком Розенблаттом в 1957 году и реализованная в виде электронной машины «Марк-1» в 1960 году. Перцептрон стал одной из первых моделей <i>нейросетей</i>, а «Марк-1» — первым в мире <i>нейрокомпьютером</i>. Несмотря на свою простоту, перцептрон способен обучаться и решать довольно сложные задачи. Основная математическая задача, с которой он справляется, — это линейное разделение любых нелинейных множеств, так называемое обеспечение линейной сепарабельности.</p>
<p>Перцептрон состоит из трёх типов элементов, а именно: поступающие от <b>сенсоров</b> сигналы передаются <b>ассоциативным</b> элементам, а затем <b>реагирующим</b> элементам. Таким образом, перцептроны позволяют создать набор «ассоциаций» между входными стимулами и необходимой реакцией на выходе. В биологическом плане это соответствует преобразованию, например, зрительной информации в физиологический ответ от двигательных нейронов. Согласно современной терминологии, перцептроны могут быть классифицированы как искусственные нейронные сети:
</p>
<ol>
<li>с одним скрытым слоем;</li>
<li>с пороговой передаточной функцией;</li>
<li>с прямым распространением сигнала.</li></ol>

<p>На фоне роста популярности нейронных сетей, в 1969 году вышла книга Марвина Минского и Сеймура Паперта, которая показала принципиальные ограничения перцептронов. Это привело к смещению интереса исследователей искусственного интеллекта в противоположную от нейросетей область символьных вычислений. Кроме того, из-за сложности математического анализа перцептронов, а также отсутствия общепринятой терминологии, возникли различные неточности и заблуждения.</p>
<p>Впоследствии интерес к нейросетям, и в частности, работам Розенблатта, возобновился. Так, например, сейчас стремительно развивается биокомпьютинг, который в своей теоретической основе вычислений, в том числе, базируется на нейронных сетях, а перцептрон воспроизводят на основе бактериородопсин-содержащих пленок.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<ul>
<li class="toclevel-1"><a href="#.D0.9F.D0.BE.D1.8F.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.B0">Появление перцептрона</a>
</li>
<li class="toclevel-1"><a href="#.D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.B0.D1.80.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.B0">Описание элементарного перцептрона</a>
</li>
<li class="toclevel-1"><a href="#.D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D0.BD.D1.8F.D1.82.D0.B8.D1.8F_.D1.82.D0.B5.D0.BE.D1.80.D0.B8.D0.B8_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.BE.D0.B2">Основные понятия теории перцептронов</a>
</li>
<ul>
<li class="toclevel-2"><a href="#.D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BD.D0.B0_.D0.BE.D1.81.D0.BD.D0.BE.D0.B2.D0.B5_.D1.81.D0.B8.D0.B3.D0.BD.D0.B0.D0.BB.D0.BE.D0.B2">Описание на основе сигналов</a>
</li>
<li class="toclevel-2"><a href="#.D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BD.D0.B0_.D0.BE.D1.81.D0.BD.D0.BE.D0.B2.D0.B5_.D0.BF.D1.80.D0.B5.D0.B4.D0.B8.D0.BA.D0.B0.D1.82.D0.BE.D0.B2">Описание на основе предикатов</a>
</li>
</ul>
<li class="toclevel-1"><a href="#.D0.98.D1.81.D1.82.D0.BE.D1.80.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B8.D1.84.D0.B8.D0.BA.D0.B0.D1.86.D0.B8.D1.8F">Историческая классификация</a>
</li>
<li class="toclevel-1"><a href="#.D0.90.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D1.8B_.D0.BE.D0.B1.D1.83.D1.87.D0.B5.D0.BD.D0.B8.D1.8F">Алгоритмы обучения</a>
</li>
<ul>
<li class="toclevel-2"><a href="#.D0.9E.D0.B1.D1.83.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81_.D1.83.D1.87.D0.B8.D1.82.D0.B5.D0.BB.D0.B5.D0.BC">Обучение с учителем</a>
</li>
<li class="toclevel-2"><a href="#.D0.9E.D0.B1.D1.83.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B1.D0.B5.D0.B7_.D1.83.D1.87.D0.B8.D1.82.D0.B5.D0.BB.D1.8F">Обучение без учителя</a>
</li>
<li class="toclevel-2"><a href="#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4_.D0.BE.D0.B1.D1.80.D0.B0.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D1.80.D0.B0.D1.81.D0.BF.D1.80.D0.BE.D1.81.D1.82.D1.80.D0.B0.D0.BD.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BE.D1.88.D0.B8.D0.B1.D0.BA.D0.B8">Метод обратного распространения ошибки</a>
</li>
</ul>
<li class="toclevel-1"><a href="#.D0.A2.D1.80.D0.B0.D0.B4.D0.B8.D1.86.D0.B8.D0.BE.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B7.D0.B0.D0.B1.D0.BB.D1.83.D0.B6.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F">Традиционные заблуждения</a>
</li>
<ul>
<li class="toclevel-2"><a href="#.D0.A2.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.BE.D0.BB.D0.BE.D0.B3.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BD.D0.B5.D1.82.D0.BE.D1.87.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Терминологические неточности</a>
</li>
<li class="toclevel-2"><a href="#.D0.A4.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.BE.D0.BD.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B7.D0.B0.D0.B1.D0.BB.D1.83.D0.B6.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F">Функциональные заблуждения</a>
</li>
<ul>
<li class="toclevel-3"><a href="#.D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B0_XOR">Задача XOR</a>
</li>
<li class="toclevel-3"><a href="#.D0.9E.D0.B1.D1.83.D1.87.D0.B0.D0.B5.D0.BC.D0.BE.D1.81.D1.82.D1.8C_.D0.BB.D0.B8.D0.BD.D0.B5.D0.B9.D0.BD.D0.BE_.D0.BD.D0.B5.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.B8.D0.BC.D1.8B.D0.BC_.D0.B7.D0.B0.D0.B4.D0.B0.D1.87.D0.B0.D0.BC">Обучаемость линейно неразделимым задачам</a>
</li>
<li class="toclevel-3"><a href="#.D0.9E.D0.B1.D1.83.D1.87.D0.B0.D0.B5.D0.BC.D0.BE.D1.81.D1.82.D1.8C_.D0.BD.D0.B0_.D0.BC.D0.B0.D0.BB.D0.BE.D0.BC_.D1.87.D0.B8.D1.81.D0.BB.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D0.BE.D0.B2">Обучаемость на малом числе примеров</a>
</li>
<li class="toclevel-3"><a href="#.D0.A1.D1.82.D0.B0.D0.B1.D0.B8.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B2.D0.B5.D1.81.D0.BE.D0.B2_.D0.B8_.D1.81.D1.85.D0.BE.D0.B4.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D1.8C">Стабилизация весов и сходимость</a>
</li>
<li class="toclevel-3"><a href="#.D0.AD.D0.BA.D1.81.D0.BF.D0.BE.D0.BD.D0.B5.D0.BD.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D1.80.D0.BE.D1.81.D1.82_.D1.87.D0.B8.D1.81.D0.BB.D0.B0_.D1.81.D0.BA.D1.80.D1.8B.D1.82.D1.8B.D1.85_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BE.D0.B2">Экспоненциальный рост числа скрытых элементов</a>
</li>
</ul>
</ul>
<li class="toclevel-1"><a href="#.D0.92.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.B8_.D0.BE.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8">Возможности и ограничения модели</a>
</li>
<ul>
<li class="toclevel-2"><a href="#.D0.92.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8">Возможности модели</a>
</li>
<li class="toclevel-2"><a href="#.D0.9E.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8">Ограничения модели</a>
</li>
<li class="toclevel-2"><a href="#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.BE.D0.B2">Применение перцептронов</a>
</li>
<ul>
<li class="toclevel-3"><a href="#.D0.9F.D1.80.D0.BE.D0.B3.D0.BD.D0.BE.D0.B7.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B8_.D1.80.D0.B0.D1.81.D0.BF.D0.BE.D0.B7.D0.BD.D0.B0.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2">Прогнозирование и распознавание образов</a>
</li>
<li class="toclevel-3"><a href="#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B0.D0.B3.D0.B5.D0.BD.D1.82.D0.B0.D0.BC.D0.B8">Управление агентами</a>
</li>
</ul>
</ul>
<li class="toclevel-1"><a href="#.D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5">См. также</a>
</li>
<li class="toclevel-1"><a href="#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F">Примечания</a>
</li>
<li class="toclevel-1"><a href="#.D0.98.D1.81.D1.82.D0.BE.D1.87.D0.BD.D0.B8.D0.BA.D0.B8">Источники</a>
</li>
<li class="toclevel-1"><a href="#.D0.9B.D0.B8.D1.82.D0.B5.D1.80.D0.B0.D1.82.D1.83.D1.80.D0.B0">Литература</a>
</li>
<li class="toclevel-1"><a href="#.D0.A1.D1.81.D1.8B.D0.BB.D0.BA.D0.B8">Ссылки</a>
</li>
</ul>
</ul></td></tr></table><hr/>
<h2><span class="mw-headline" id=".D0.9F.D0.BE.D1.8F.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.B0">Появление перцептрона</span></h2>

<p>искусственного нейрона]] — базового элемента любой нейронной сети</p>
<p>В 1943 году в своей статье «Логическое исчисление идей, относящихся к нервной активности» Уоррен Мак-Каллок и  предложили понятие искусственной нейронной сети. В частности, ими была предложена модель искусственного нейрона. Дональд Хебб в работе «Организация поведения» 1949 года описал основные принципы обучения нейронов.</p>
<p>Эти идеи несколько лет спустя развил американский нейрофизиолог Фрэнк Розенблатт. Он предложил схему устройства, моделирующего процесс человеческого восприятия, и назвал его «перцептроном». Перцептрон передавал сигналы от фотоэлементов, представляющих собой сенсорное поле, в блоки электромеханических ячеек памяти. Эти ячейки соединялись между собой случайным образом в соответствии с принципами коннективизма. В 1957 году в Корнелльской Лаборатории Аэронавтики успешно было завершено моделирование работы перцептрона на компьютере IBM 704, а два года спустя, 23 июня 1960 года в Корнелльском университете, был продемонстрирован первый нейрокомпьютер — <b>«Марк-1»</b>, который был способен распознавать некоторые из букв английского алфавита.</p>
<p>Фрэнк Розенблатт со своим творением — «Марк-1».
Чтобы «научить» перцептрон классифицировать образы, был разработан специальный итерационный метод обучения проб и ошибок, напоминающий процесс обучения человека — метод коррекции ошибки. Кроме того, при распознании той или иной буквы перцептрон мог выделять характерные особенности буквы, статистически чаще встречающиеся, чем малозначимые отличия в индивидуальных случаях. Тем самым перцептрон был способен обобщать буквы, написанные различным образом (почерком), в один обобщённый образ. Однако возможности перцептрона были ограниченными: машина не могла надежно распознавать частично закрытые буквы, а также буквы иного размера, расположенные со сдвигом или поворотом, нежели те, которые использовались на этапе ее обучения.</p>
<p>Отчёт по первым результатам появился ещё в 1958 году — тогда Розенблаттом была опубликована статья «Перцептрон: Вероятная модель хранения и организации информации в головном мозге». Но подробнее свои теории и предположения относительно процессов восприятия и перцептронов он описывает 1962 году, в книге «Принципы нейродинамики: Перцептроны и теория механизмов мозга». В книге он рассматривает не только уже готовые модели перцептрона с одним скрытым слоем, но и многослойных перцептронов с перекрёстными (третья глава) и обратными (четвёртая глава) связями. В книге также вводится ряд важных идей и теорем, например, доказывается теорема сходимости перцептрона.</p>
<h2><span class="mw-headline" id=".D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.B0.D1.80.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.B0">Описание элементарного перцептрона</span></h2>
<p>Поступление сигналов с сенсорного поля в решающие блоки элементарного перцептрона в его физическом воплощении.
Логическая схема элементарного перцептрона. Веса S—A связей могут иметь значения ?1, +1 или 0 (то есть отсутствие связи). Веса A—R связей W могут быть любыми.
Элементарный перцептрон состоит из элементов 3-х типов: S-элементов, A-элементов и <i>одного</i> R-элемента. S-элементы — это слой сенсоров, или рецепторов. В физическом воплощении они соответствуют, например, светочувствительным клеткам сетчатки глаза или фоторезисторам матрицы камеры. Каждый рецептор может находиться в одном из двух состояний — <i>покоя</i> или <i>возбуждения</i>, и только в последнем случае он передаёт единичный сигнал в следующий слой, ассоциативным элементам.</p>
<p>A-элементы называются ассоциативными, потому что каждому такому элементу, как правило, соответствует целый набор (ассоциация) S-элементов. A-элемент активизируется, как только количество сигналов от S-элементов на его входе превысило некоторую величину ?. Таким образом, если набор соответствующих S-элементов располагается на сенсорном поле в форме буквы «Д», A-элемент активизируется, если достаточное количество рецепторов сообщило о появлении «белого пятна света» в их окрестности, то есть A-элемент будет как бы ассоциирован с наличием/отсутствием буквы «Д» в некоторой области.</p>
<p>Сигналы от возбудившихся A-элементов, в свою очередь, передаются в сумматор R, причём сигнал от i-го ассоциативного элемента передаётся с коэффициентом <span class="math">w_{i}</span>. Этот коэффициент называется <i>весом</i> A—R связи.</p>
<p>Так же как и A-элементы, R-элемент подсчитывает сумму значений входных сигналов, помноженных на веса (линейную форму). R-элемент, а вместе с ним и элементарный перцептрон, выдаёт «1», если линейная форма превышает порог ?, иначе на выходе будет «?1». Математически, функцию, реализуемую R-элементом, можно записать так:
</p>
<dl>
<dd><span class="math">f(x) = \operatorname{sign}(\sum_{i=1}^{n} w_i x_i - \theta)</span></dd></dl>

<p>Обучение элементарного перцептрона состоит в изменении весовых коэффициентов <span class="math">w_i</span> связей A—R. Веса связей S—A (которые могут принимать значения {?1; 0; +1}) и значения порогов A-элементов выбираются случайным образом в самом начале и затем не изменяются. (Описание алгоритма см. ниже.)</p>
<p>После обучения перцептрон готов работать в режиме <i>распознавания</i> или <i>обобщения</i>. В этом режиме перцептрону предъявляются ранее неизвестные ему объекты, и перцептрон должен установить, к какому классу они принадлежат. Работа перцептрона состоит в следующем: при предъявлении объекта, возбудившиеся A-элементы передают сигнал R-элементу, равный сумме соответствующих коэффициентов <span class="math">w_i</span>. Если эта сумма положительна, то принимается решение, что данный объект принадлежит к первому классу, а если она отрицательна — то ко второму.</p>
<h2><span class="mw-headline" id=".D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D0.BD.D1.8F.D1.82.D0.B8.D1.8F_.D1.82.D0.B5.D0.BE.D1.80.D0.B8.D0.B8_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.BE.D0.B2">Основные понятия теории перцептронов</span></h2>
<p>Серьёзное ознакомление с теорией перцептронов требует знания базовых определений и теорем, совокупность которых и представляет собой базовую основу для всех последующих видов искусственных нейронных сетей. Но, как минимум, необходимо понимание хотя бы с точки зрения теории сигналов, являющееся оригинальным, то есть описанное автором перцептрона Ф. Розенблаттом.</p>
<h3><span class="mw-headline" id=".D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BD.D0.B0_.D0.BE.D1.81.D0.BD.D0.BE.D0.B2.D0.B5_.D1.81.D0.B8.D0.B3.D0.BD.D0.B0.D0.BB.D0.BE.D0.B2">Описание на основе сигналов</span></h3>
<p>Пороговая функция, реализуемая простыми S- и A-элементами.
Пороговая функция, реализуемая простым R-элементом.
Для начала определим составные элементы перцептрона, которые являются частными случаями искусственного нейрона с пороговой передаточной функцией.
</p>
<ul>
<li>Простым <b>S-элементом</b> (сенсорным) является чувствительный элемент, который от воздействия какого-либо из видов энергии (например, света, звука, давления, тепла и т. п.) вырабатывает сигнал. Если входной сигнал превышает некоторый порог ?, на выходе элемента получаем +1, в противном случае — 0.</li>
<li>Простым <b>A-элементом</b> (ассоциативным) называется логический решающий элемент, который даёт выходной сигнал +1, когда алгебраическая сумма его входных сигналов превышает некоторую пороговую величину ? (говорят, что элемент <i>активный</i>), в противном случае выход равен нулю.</li>
<li>Простым <b>R-элементом</b> (реагирующим, то есть действующим) называется элемент, который выдаёт сигнал +1, если сумма его входных сигналов является строго положительной, и сигнал ?1, если сумма его входных сигналов является строго отрицательной. Если сумма входных сигналов равна нулю, выход считается либо равным нулю, либо неопределённым.</li></ul>

<p>Если на выходе любого элемента мы получаем 1, то говорят, что элемент <b>активен</b> или <b>возбуждён</b>.</p>
<p>Все рассмотренные элементы называются <i>простыми</i>, так как они реализуют <i>скачкообразные функции</i>. Розенблатт утверждал также, что для решения более сложных задач могут потребоваться другие виды функций, например, линейная.</p>
<p>В результате Розенблатт ввёл следующие определения:
</p>
<ul>
<li><b>Перцептрон</b> представляет собой сеть, состоящую из S-, A-, R-элементов, с переменной матрицей взаимодействия W (элементы которой <span class="math">w_{ij}</span> — весовые коэффициенты), определяемой последовательностью прошлых состояний активности сети.</li>
<li><b>Перцептроном с последовательными связями</b> называется система, в которой все связи, начинающиеся от элементов с логическим расстоянием d от ближайшего S-элемента, оканчиваются на элементах с логическим расстоянием d+1 от ближайшего S-элемента.</li>
<li><b>Простым перцептроном</b> называется любая система, удовлетворяющая следующим пяти условиям:
<ol>
<li>в системе имеется только один R-элемент (естественно, он связан всеми A-элементами);</li>
<li>система представляет собой перцептрон с последовательными связями, идущими только от S-элементов к A-элементам и от A-элементов к R-элементам;</li>
<li>веса всех связей от S-элементов к A-элементам (S—A связей) неизменны;</li>
<li>время передачи каждой связи равно либо нулю, либо фиксированной постоянной <span class="math">\tau</span>;</li>
<li>все активирующие функции S-, A-, R-элементов имеют вид <span class="math">U_{i}(t) = f(a_{i}(t))</span>, где <span class="math">a_{i}(t)</span> — алгебраическая сумма всех сигналов, поступающих одновременно на вход элемента <span class="math">u_{i}</span></li></ol></li>
<li><b>Элементарным перцептроном</b> называется простой перцептрон, у которого <i>все элементы — простые</i>. В этом случае его активизирующая функция имеет вид <span class="math">c_{ij}(t) = U_{i}(t - \tau)w_{ij}(t)</span>.</li></ul>

<p>Дополнительно можно указать на следующие концепции, предложенные в книге, и позднее развитые в рамках теории нейронных сетей:
</p>
<ul>
<li><b>Перцептрон с перекрёстными связями</b> - это система, в которой существуют связи между элементами одного типа (S, A или R), находящиеся на одинаковом логическом расстоянии от S-элементов, причем все остальные связи — последовательного типа.</li>
<li><b>Перцептрон с обратной связью</b> - это система, в которой существует хотя бы одна связь от логически более удалённого элемента к менее удалённому. Согласно современной терминологии такие сети называются рекуррентными.</li>
<li><b>Перцептрон с переменными S-A связями</b> - это система, в которой снято ограничение на фиксированные связи от S-элементов к A-элементам. Доказано, что путём оптимизации S—A связей можно добиться значительного улучшения характеристик перцептрона.</li></ul>

<h3><span class="mw-headline" id=".D0.9E.D0.BF.D0.B8.D1.81.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BD.D0.B0_.D0.BE.D1.81.D0.BD.D0.BE.D0.B2.D0.B5_.D0.BF.D1.80.D0.B5.D0.B4.D0.B8.D0.BA.D0.B0.D1.82.D0.BE.D0.B2">Описание на основе предикатов</span></h3>

<p>Марвин Минский изучал свойства параллельных вычислений, частным случаем которых на то время был перцептрон. Для анализа его свойств ему пришлось переизложить теорию перцептронов на язык предикатов. Суть подхода заключалась в следующем:
</p>
<ul>
<li>множеству сигналов от S-элементов была сопоставлена переменная X;</li>
<li>каждому A-элементу был сопоставлен предикат ?(X) <i>(фи от икс)</i>, названный <b>частным предикатом</b>;</li>
<li>каждому R-элементу был сопоставлен предикат ? <i>(пси)</i>, зависящий от частных предикатов;</li>
<li>наконец, <b>перцептроном</b> было названо устройство, способное вычислять все предикаты типа ?.</li></ul>

<p>Применительно к «зрительному» перцептрону, переменная X символизировала образ какой-либо геометрической фигуры (<i>стимул</i>). Частный предикат позволял «распознавать» каждый свою фигуру. Предикат ? означал ситуацию, когда линейная комбинация <span class="math">a_{1}\phi_{1} + \ldots + a_{n}\phi_{n}</span> (<span class="math">a_{i}</span> — коэффициенты передачи) превышала некоторый порог ?.</p>
<p>Учёные выделили 5 семейств перцептронов, обладающих, по их мнению, интересными свойствами:
</p>
<ol>
<li><b>Перцептроны, ограниченные по диаметру</b> — каждая фигура X, распознаваемая частными предикатами, не превосходит по диаметру некоторую фиксированную величину.</li>
<li><b>Перцептроны ограниченного порядка</b> — каждый частный предикат зависит от ограниченного количества точек из X.</li>
<li><b>Перцептроны Гамбы</b> — каждый частный предикат должен быть линейной пороговой функцией, то есть мини-перцептроном.</li>
<li><b>Случайные перцептроны</b> — перцептроны ограниченного порядка, где частные предикаты представляют собой случайно выбранные булевы функции. В книге отмечается, что именно эта модель наиболее подробно изучалась группой Розенблатта.</li>
<li><b>Ограниченные перцептроны</b> — множество частных предикатов бесконечно, а множество возможных значений коэффициентов <span class="math">a_{i}</span> конечно.</li></ol>

<p>Хотя такой математический аппарат позволил применить анализ только к <b>элементарному перцептрону</b> Розенблатта, он вскрыл много принципиальных ограничений для параллельных вычислений, от которых не свободен ни один вид современных искусственных нейронных сетей.</p>
<h2><span class="mw-headline" id=".D0.98.D1.81.D1.82.D0.BE.D1.80.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B0.D1.8F_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B8.D1.84.D0.B8.D0.BA.D0.B0.D1.86.D0.B8.D1.8F">Историческая классификация</span></h2>
<p>Архитектура многослойного перцептрона (обоих подтипов).
Понятие перцептрона имеет интересную, но незавидную историю. В результате неразвитой терминологии нейронных сетей прошлых лет, резкой критики и непонимания задач исследования перцептронов, а иногда и ложного освещения прессой, изначальный смысл этого понятия исказился. Сравнивая разработки Розенблатта и современные обзоры и статьи, можно выделить 4 довольно обособленных класса перцептронов:</p>

<dl>
<dt>Перцептрон с одним скрытым слоем</dt>
<dd>Это классический перцептрон, которому посвящена бо?льшая часть книги Розенблатта, и рассматриваемый в данной статье: у него имеется по одному слою S-, A- и R-элементов.</dd></dl>


<dl>
<dt>Однослойный перцептрон</dt>
<dd>Это модель, в которой входные элементы напрямую соединены с выходными с помощью системы весов. Является простейшей сетью прямого распространения — линейным классификатором, и частным случаем классического перцептрона, в котором каждый S-элемент однозначно соответствует одному A-элементу, S—A связи имеют вес +1 и все A-элементы имеют порог ? = 1. Однослойные перцептроны фактически являются формальными нейронами, то есть пороговыми элементами Мак-Каллока — Питтса. Они имеют множество ограничений, в частности, они не могут идентифицировать ситуацию, когда на их входы поданы разные сигналы («задача XOR», см. ниже).</dd></dl>


<dl>
<dt>Многослойный перцептрон (по Розенблатту)</dt>
<dd>Это перцептрон, в котором присутствуют дополнительные слои A-элементов. Его анализ провёл Розенблатт в третьей части своей книги.</dd></dl>


<dl>
<dt>Многослойный перцептрон (по Румельхарту)</dt>
<dd>Это перцептрон, в котором присутствуют дополнительные слои A-элементов, причём, обучение такой сети проводится по методу обратного распространения ошибки, и обучаемыми являются все слои перцептрона (в том числе S—A). Является частным случаем многослойного перцептрона Розенблатта.</dd></dl>

<p>В настоящее время в литературе под термином «перцептрон» понимается чаще всего однослойный перцептрон (), причём, существует распространённое заблуждение, что именно этот простейший тип моделей предложил Розенблатт. В противоположность однослойному ставят «многослойный перцептрон» (), опять же, чаще всего подразумевая многослойный перцептрон Румельхарта, а не Розенблатта. Классический перцептрон в такой дихотомии относят к многослойным.</p>
<h2><span class="mw-headline" id=".D0.90.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D1.8B_.D0.BE.D0.B1.D1.83.D1.87.D0.B5.D0.BD.D0.B8.D1.8F">Алгоритмы обучения</span></h2>
<p>Важным свойством любой нейронной сети является способность к обучению. Процесс обучения является процедурой настройки весов и порогов с целью уменьшения разности между желаемыми (целевыми) и получаемыми векторами на выходе. В своей книге Розенблатт пытался классифицировать различные алгоритмы обучения перцептрона, называя их системами подкрепления.
</p>
<dl>
<dd><b>Система подкрепления</b> - это любой набор правил, на основании которых можно изменять с течением времени матрицу взаимодействия (или состояние памяти) перцептрона.</dd></dl>
<p>Описывая эти системы подкрепления и уточняя возможные их виды, Розенблатт основывался на идеях Д. Хебба об обучении, предложенных им в 1949 году, которые можно перефразировать в следующее правило, состоящее из двух частей:
</p>
<ul>
<li>Если два нейрона по обе стороны синапса (соединения) активизируются одновременно (то есть синхронно), то прочность этого соединения возрастает.</li>
<li>Если два нейрона по обе стороны синапса активизируются асинхронно, то такой синапс ослабляется или вообще отмирает.</li></ul>

<h3><span class="mw-headline" id=".D0.9E.D0.B1.D1.83.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81_.D1.83.D1.87.D0.B8.D1.82.D0.B5.D0.BB.D0.B5.D0.BC">Обучение с учителем</span></h3>

<p>Классический метод обучения перцептрона — это <i>метод коррекции ошибки</i>. Он представляет собой такой вид обучения с учителем, при котором вес связи не изменяется до тех пор, пока текущая реакция перцептрона остается правильной. При появлении неправильной реакции вес изменяется на единицу, а знак (+/-) определяется противоположным от знака ошибки.</p>
<p>Допустим, мы хотим обучить перцептрон разделять два класса объектов так, чтобы при предъявлении объектов первого класса выход перцептрона был положителен (+1), а при предъявлении объектов второго класса — отрицательным (?1). Для этого выполним следующий алгоритм:
</p>
<ol>
<li>Случайным образом выбираем пороги для A-элементов и устанавливаем связи S—A (далее они изменяться не будут).</li>
<li>Начальные коэффициенты <span class="math">w_i</span> полагаем равными нулю.</li>
<li>Предъявляем <b>обучающую выборку</b>: объекты (например, круги либо квадраты) с указанием класса, к которым они принадлежат.
<ul>
<li>Показываем перцептрону объект первого класса. При этом некоторые A-элементы возбудятся. Коэффициенты <span class="math">w_i</span>, соответствующие этим возбуждённым элементам, <i>увеличиваем</i> на 1.</li>
<li>Предъявляем объект второго класса и коэффициенты <span class="math">w_i</span> тех A-элементов, которые возбудятся при этом показе, <i>уменьшаем</i> на 1.</li></ul></li>
<li>Обе части шага 3 выполним для всей обучающей выборки. В результате обучения сформируются значения весов связей <span class="math">w_i</span>.</li></ol>

<p><b>Теорема сходимости перцептрона</b>, описанная и доказанная Ф. Розенблаттом (с участием Блока, Джозефа, Кестена и других исследователей, работавших вместе с ним), показывает, что элементарный перцептрон, обучаемый по такому алгоритму, независимо от начального состояния весовых коэффициентов и последовательности появления стимулов <i>всегда</i> приведет к достижению решения за конечный промежуток времени.</p>
<h3><span class="mw-headline" id=".D0.9E.D0.B1.D1.83.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B1.D0.B5.D0.B7_.D1.83.D1.87.D0.B8.D1.82.D0.B5.D0.BB.D1.8F">Обучение без учителя</span></h3>
<p>Кроме классического метода обучения перцептрона Розенблатт также ввёл понятие об обучении без учителя, предложив следующий способ обучения:
</p>
<dl>
<dd><b>Альфа-система подкрепления</b> - это система подкрепления, при которой веса всех <i>активных</i> связей <span class="math">c_{ij}</span>, которые ведут к элементу <span class="math">u_j</span>, изменяются на одинаковую величину r, а веса <i>неактивных</i> связей за это время не изменяются.</dd></dl>
<p>Затем, с разработкой понятия многослойного перцептрона, альфа-система была модифицирована и её стали называть <i>дельта-правило</i>. Модификация была проведена с целью сделать функцию обучения дифференцируемой (например, сигмоидной), что в свою очередь нужно для применения метода градиентного спуска, благодаря которому возможно обучение более одного слоя.</p>
<h3><span class="mw-headline" id=".D0.9C.D0.B5.D1.82.D0.BE.D0.B4_.D0.BE.D0.B1.D1.80.D0.B0.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D1.80.D0.B0.D1.81.D0.BF.D1.80.D0.BE.D1.81.D1.82.D1.80.D0.B0.D0.BD.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BE.D1.88.D0.B8.D0.B1.D0.BA.D0.B8">Метод обратного распространения ошибки</span></h3>

<p>Для обучения многослойных сетей рядом учёных, в том числе Д. Румельхартом, был предложен градиентный алгоритм обучения с учителем, проводящий сигнал ошибки, вычисленный <i>выходами</i> перцептрона, к его <i>входам</i>, слой за слоем. Сейчас это самый популярный метод обучения многослойных перцептронов. Его преимущество в том, что он может обучить <i>все</i> слои нейронной сети, и его легко просчитать локально. Однако этот метод является очень долгим, к тому же, для его применения нужно, чтобы передаточная функция нейронов была дифференцируемой. При этом в перцептронах пришлось отказаться от бинарного сигнала, и пользоваться на входе непрерывными значениями.</p>
<h2><span class="mw-headline" id=".D0.A2.D1.80.D0.B0.D0.B4.D0.B8.D1.86.D0.B8.D0.BE.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B7.D0.B0.D0.B1.D0.BB.D1.83.D0.B6.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F">Традиционные заблуждения</span></h2>
<p>В результате популяризации искусственных нейронных сетей журналистами и маркетологами был допущен ряд неточностей, которые, при недостаточном изучении оригинальных работ по этой тематике, неверно истолковывались молодыми (на то время) учёными. В результате по сей день можно встретиться с недостаточно глубокой трактовкой функциональных возможностей перцептрона по сравнению с другими нейронными сетями, разработанными в последующие годы.</p>
<h3><span class="mw-headline" id=".D0.A2.D0.B5.D1.80.D0.BC.D0.B8.D0.BD.D0.BE.D0.BB.D0.BE.D0.B3.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BD.D0.B5.D1.82.D0.BE.D1.87.D0.BD.D0.BE.D1.81.D1.82.D0.B8">Терминологические неточности</span></h3>
<p>Самая распространённое ошибка, связанная с терминологией, это определение перцептрона как <i>нейронной сети без скрытых слоёв</i> (однослойного перцептрона, см. выше). Эта ошибка связана с недостаточно проработанной терминологией в области нейросетей на раннем этапе их разработки. Ф. Уоссерменом была сделана попытка определенным образом классифицировать различные виды нейронных сетей:</p>
<p>Как видно из публикаций, нет общепринятого способа подсчёта числа слоёв в сети. Многослойная сеть состоит из чередующихся множеств нейронов и весов. Входной слой не выполняет суммирования. Эти нейроны служат лишь в качестве разветвлений для первого множества весов и не влияют на вычислительные возможности сети. По этой причине первый слой не принимается во внимание при подсчёте слоев, и сеть считается двухслойной, так как только два слоя выполняют вычисления. Далее, веса слоя считаются связанными со следующими за ними нейронами. Следовательно, слой состоит из множества весов со следующими за ними нейронами, суммирующими взвешенные сигналы.</p>
<p>В результате такого представления перцептрон попал под определение «однослойная нейронная сеть». Отчасти это верно, потому что у него нет скрытых слоев <i>обучающихся</i> нейронов (веса которых адаптируются к задаче). И поэтому всю совокупность фиксированных связей системы из S- к A-элементам, можно логически заменить набором (модифицированных по жёсткому правилу) <i>новых</i> входных сигналов, поступающих сразу на А-элементы (устранив тем самым вообще первый слой связей). Но тут как раз не учитывают, что такая модификация превращает нелинейное представление задачи в линейное.</p>
<p>Поэтому просто игнорирование не обучаемых слоев с фиксированными связями (в элементарном перцептроне это S—A связи) позволяет делать неправильные выводы о возможностях нейросети. Так, Минский поступил очень корректно, переформулировав А-элемент как предикат (то есть функцию); наоборот, Уоссермен уже потерял такое представление и у него А-элемент — просто вход (почти эквивалентный S-элементу). При такой терминологической путанице упускается из виду тот факт, что в перцептроне происходит отображение рецептивного поля S-элементов на ассоциативное поле А-элементов, в результате чего и происходит преобразование любой линейно неразделимой задачи в линейно разделимую.</p>
<h3><span class="mw-headline" id=".D0.A4.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.BE.D0.BD.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B7.D0.B0.D0.B1.D0.BB.D1.83.D0.B6.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F">Функциональные заблуждения</span></h3>
<p>Решение элементарным перцептроном «задачи XOR». Порог всех элементов ? = 0.
Большинство функциональных заблуждений сводятся к якобы невозможности решения перцептроном нелинейно разделяемой задачи. Но вариаций на эту тему достаточно много, рассмотрим главные из них.</p>
<h4><span class="mw-headline" id=".D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B0_XOR">Задача XOR</span></h4>
<p><i>Перцептрон не способен решить «задачу XOR».</i>
</p>
<dl>
<dd>Очень распространённое и самое несерьёзное заявление. На изображении справа показано решение этой задачи перцептроном. Данное заблуждение возникает, во-первых, из-за того, что неправильно интерпретируют определение перцептрона, данного Минским (см. выше), а именно, предикаты сразу приравнивают входам, хотя предикат у Минского — это функция, идентифицирующая целый набор входных значений. Во-вторых, из-за того, что классический перцептрон Розенблатта путают с однослойным перцептроном (из-за терминологической неточности, описанной выше).</dd></dl>
<p>Следует обратить особое внимание на то, что &#34;однослойный персептрон&#34; в современной терминологии и &#34;однослойный персептрон&#34; в терминологии Уоссермана - разные объекты. И объект, изображённый на иллюстрации, в терминологии Уоссермана есть двухслойный персептрон.</p>
<h4><span class="mw-headline" id=".D0.9E.D0.B1.D1.83.D1.87.D0.B0.D0.B5.D0.BC.D0.BE.D1.81.D1.82.D1.8C_.D0.BB.D0.B8.D0.BD.D0.B5.D0.B9.D0.BD.D0.BE_.D0.BD.D0.B5.D1.80.D0.B0.D0.B7.D0.B4.D0.B5.D0.BB.D0.B8.D0.BC.D1.8B.D0.BC_.D0.B7.D0.B0.D0.B4.D0.B0.D1.87.D0.B0.D0.BC">Обучаемость линейно неразделимым задачам</span></h4>
<p><i>Выбором случайных весов <b>можно</b> достигнуть обучения и линейно неразделимым (вообще, любым) задачам, <b>но только если повезет</b>, и в новых переменных (выходах A-нейронов) задача окажется линейно разделимой. Но может и не повезти.</i></p>

<dl>
<dd>Теорема сходимости перцептрона доказывает, что нет и не может быть никакого «может и не повезти»; при равенстве А-элементов числу стимулов и не особенной G-матрице — вероятность решения равна 100 %. То есть при отображении рецепторного поля на ассоциативное поле большей на одну размерности случайным (нелинейным) оператором нелинейная задача превращается в линейно разделимую. А следующий обучаемый слой уже находит линейное решение в другом пространстве входов.</dd></dl>


<dl>
<dd>Например, обучение перцептрона для решения «задачи XOR» (см. на иллюстрации) проводится следующими этапами:</dd></dl>
<div align="center">

<div style="page-break-inside: avoid;">
<table class="wikitable">
<tr>
<th rowspan="2">Веса</th>
<th colspan="9">Итерации</th></tr>
<tr>
<th colspan="3">1</th>
<th>2</th>
<th colspan="2">3</th>
<th colspan="2">4</th>
<th>5</th></tr>
<tr>
<th>w1</th>
<td width="40px">0</td>
<td width="40px">1</td>
<td width="40px">1</td>
<td width="40px">1</td>
<td width="40px">1</td>
<td width="40px">2</td>
<td width="40px">2</td>
<td width="40px">2</td>
<td width="40px">2</td></tr>
<tr>
<th>w2</th>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td></tr>
<tr>
<th>w3</th>
<td>?1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>?1</td>
<td>0</td>
<td>?1</td>
<td>0</td>
<td>?1</td></tr>
<tr>
<th>Входные сигналы (x, y)</th>
<td>1, 1</td>
<td>0, 1</td>
<td>1, 0</td>
<td>1, 1</td>
<td>1, 1</td>
<td>0, 1</td>
<td>1, 1</td>
<td>1, 0</td>
<td>1, 1</td></tr></table></div></div>

<h4><span class="mw-headline" id=".D0.9E.D0.B1.D1.83.D1.87.D0.B0.D0.B5.D0.BC.D0.BE.D1.81.D1.82.D1.8C_.D0.BD.D0.B0_.D0.BC.D0.B0.D0.BB.D0.BE.D0.BC_.D1.87.D0.B8.D1.81.D0.BB.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D0.BE.D0.B2">Обучаемость на малом числе примеров</span></h4>
<p><i>Если в задаче размерность входов довольно высока, а обучающих примеров мало, то в таком «слабо заполненном» пространстве число удач может и не оказаться малым. Это свидетельствует лишь о частном случае пригодности перцептрона, а не его универсальности.</i></p>

<dl>
<dd>Данный аргумент легко проверить на тестовой задаче под названием «шахматная доска» или «губка с водой»:</dd></dl>


<dl>
<dd>Могут быть вариации данной задачи, например:</dd></dl>


<dl>
<dd>Если данный аргумент справедлив, то перцептрон не сможет ни при каких условиях обучиться, не делая ни одной ошибки. Иначе перцептрон не ошибётся ни разу.</dd></dl>


<dl>
<dd>На практике оказывается, что данная задача очень проста для перцептрона: чтобы ее решить, перцептрону достаточно 1500 А-элементов (вместо полных 65 536, необходимых для любой задачи). При этом число итераций порядка 1000. При 1000 А-элементов перцептрон не сходится за 10 000 итераций. Если же увеличить число А-элементов до 40 000, то схождения можно ожидать за 30—80 итераций.</dd></dl>


<dl>
<dd>Такой аргумент появляется из-за того, что данную задачу путают с задачей Минского «о предикате „чётность“».</dd></dl>

<h4><span class="mw-headline" id=".D0.A1.D1.82.D0.B0.D0.B1.D0.B8.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B2.D0.B5.D1.81.D0.BE.D0.B2_.D0.B8_.D1.81.D1.85.D0.BE.D0.B4.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D1.8C">Стабилизация весов и сходимость</span></h4>
<p><i>В перцептроне Розенблатта столько А-элементов, сколько входов. И сходимость по Розенблатту, это стабилизация весов.</i></p>

<dl>
<dd>У Розенблатта читаем:</dd></dl>

<p>Если число стимулов в пространстве W равно n &#62; N (то есть больше числа А-элементов элементарного перцептрона), то существует некоторая классификация , для которой решения не существует.</p>

<dl>
<dd>Отсюда следует, что:
<ol>
<li>у Розенблатта число А-элементов равно числу стимулов (обучающих примеров), а не числу входов;</li>
<li>сходимость по Розенблатту, это не стабилизация весов, а наличие всех требуемых классификаций, то есть по сути отсутствие ошибок.</li></ol></dd></dl>

<h4><span class="mw-headline" id=".D0.AD.D0.BA.D1.81.D0.BF.D0.BE.D0.BD.D0.B5.D0.BD.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D1.80.D0.BE.D1.81.D1.82_.D1.87.D0.B8.D1.81.D0.BB.D0.B0_.D1.81.D0.BA.D1.80.D1.8B.D1.82.D1.8B.D1.85_.D1.8D.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.BE.D0.B2">Экспоненциальный рост числа скрытых элементов</span></h4>
<p><i>Если весовые коэффициенты к элементам скрытого слоя (А-элементам) фиксированы, то необходимо, чтобы количество элементов скрытого слоя (либо их сложность) экспоненциально возрастало с ростом размерности задачи (числа рецепторов). Тем самым, теряется их основное преимущество — способность решать задачи произвольной сложности при помощи простых элементов.</i></p>

<dl>
<dd>Розенблаттом было показано, что число А-элементов зависит только от числа стимулов, которые нужно распознать (см. предыдущий пункт или теорему сходимости перцептрона). Таким образом, при возрастании числа рецепторов, если количество А-элементов фиксировано, непосредственно не зависит возможность перцептрона к решению задач произвольной сложности.</dd></dl>


<dl>
<dd>Такое заблуждение происходит от следующей фразы Минского:</dd></dl>

<p>При исследовании предиката «чётность» мы видели, что коэффициенты могут расти с ростом |R| (числа точек на изображении) экспоненциально.</p>

<dl>
<dd>Кроме того, Минский исследовал и другие предикаты, например «равенство». Но все эти предикаты представляют собой достаточно специфическую задачу на обобщение, а не на распознавание или прогнозирование. Так, например, чтобы перцептрон мог выполнять предикат «четность» — он должен сказать, четно или нет число чёрных точек на чёрно-белом изображении; а для выполнения предиката «равенство» — сказать, равна ли правая часть изображения левой. Ясно, что такие задачи выходят за рамки задач распознавания и прогнозирования, и представляют собой задачи на обобщение или просто на подсчет определенных характеристик. Это и было убедительно показано Минским, и является ограничением не только перцептронов, но и всех параллельных алгоритмов, которые не способны быстрее последовательных алгоритмов вычислить такие предикаты.</dd></dl>


<dl>
<dd>Поэтому такие задачи ограничивают возможности всех нейронных сетей и перцептронов в частности, но это никак не связанно с фиксированными связями первого слоя; так как во-первых, речь шла о величине коэффициентов связей второго слоя, а во-вторых, вопрос только в эффективности, а не принципиальной возможности. То есть перцептрон можно обучить и этой задаче, но требуемые для этого емкость памяти и скорость обучения будут больше, чем при применении простого последовательного алгоритма. Введение же обучаемых весовых коэффициентов в первом слое лишь ухудшит положение дел, ибо потребует большего времени обучения, потому что переменные связи между S и A скорее препятствуют, чем способствуют процессу обучения. Причём, при подготовке перцептрона к задаче распознавания стимулов особого типа, для сохранения эффективности потребуются особые условия стохастического обучения, что было показано Розенблаттом в экспериментах с перцептроном с переменными S—A связями.</dd></dl>

<h2><span class="mw-headline" id=".D0.92.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.B8_.D0.BE.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8">Возможности и ограничения модели</span></h2>


<h3><span class="mw-headline" id=".D0.92.D0.BE.D0.B7.D0.BC.D0.BE.D0.B6.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8">Возможности модели</span></h3>
<p>классификации]] объектов. Зелёная линия — граница классов.
Сам Розенблатт рассматривал перцептрон прежде всего как следующий важный шаг в сторону исследования и использования нейронных сетей, а не как оконченный вариант «машины, способной мыслить». Ещё в предисловии к своей книге он, отвечая на критику, отмечал, что «программа по исследованию перцептрона связана главным образом <i>не</i> с изобретением устройств, обладающих „искусственным интеллектом“, а с изучением физических структур и нейродинамических принципов».</p>
<p>Розенблатт предложил ряд психологических тестов для определения возможностей нейросетей: эксперименты по различению, обобщению, по распознаванию последовательностей, образованию абстрактных понятий, формированию и свойствам «самосознания», творческого воображения и другие. Некоторые из этих экспериментов далеки от современных возможностей перцептронов, поэтому их развитие происходит больше философски в пределах направления коннективизма. Тем не менее, для перцептронов установлены два важных факта, находящие применение в практических задачах: <i>возможность классификации</i> (объектов) и <i>возможность аппроксимации</i> (границ классов и функций).</p>
<p>Важным свойством перцептронов является их способность к обучению, причём по довольно простому и эффективному алгоритму (см. выше). В последнее время исследователи начинают обращать внимание именно на оригинальную версию перцептрона, так как обучение многослойного перцептрона с помощью метода обратного распространения ошибки выявило существенные ограничения на скорость обучения. Попытки обучать многослойный перцептрон методом обратного распространения ошибок приводят к экспоненциальному росту вычислительных затрат. Если же воспользоваться методом прямого распространения (<b>ГОСТ Р 52633.5-2011 «Защита информации. Техника защиты информации. Автоматическое обучение нейросетевых преобразователей биометрия-код доступа»</b>), то вычислительная сложность алгоритма обучения становится линейной. Это позволяет снять проблему обучения нейронных сетей с очень большим числом входов и выходов, а также иметь любое число слоев сети перцептронов. Подробнее о снятии &#34;проклятия размерности&#34; можно прочитать в работе Иванова А.И. &#34;Подсознание искусственного интеллекта: программирование автоматов нейросетевой биометрии языком их обучения&#34; <a class="externallink" href="http://пниэи.рф/activity/science/bio_neuro.pdf." rel="nofollow" title="http://пниэи.рф/activity/science/bio_neuro.pdf.">http://пниэи.рф/activity/science/bio_neuro.pdf.</a></p>
<h3><span class="mw-headline" id=".D0.9E.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8">Ограничения модели</span></h3>



<p>Некоторые задачи, которые перцептрон не способен решить: 1, 2 — преобразования группы переносов; 3 — из какого количества частей состоит фигура? 4 — внутри какого объекта нет другой фигуры? 5 — какая фигура внутри объектов повторяется два раза? (3, 4, 5 — задачи на определение «связности» фигур.)</p>
<p>Сам Розенблатт выделил два фундаментальных ограничения для трёхслойных перцептронов (состоящих из одного S-слоя, одного A-слоя и R-слоя): отсутствие у них способности к обобщению своих характеристик на новые стимулы или новые ситуации, а также неспособность анализировать сложные ситуации во внешней среде путём расчленения их на более простые.</p>
<p>В 1969 году Марвин Минский и Сеймур Паперт опубликовали книгу «Перцептроны», где математически показали, что перцептроны, подобные розенблаттовским, принципиально не в состоянии выполнять многие из тех функций, которые хотели получить от перцептронов. К тому же, в то время была слабо развита теория о параллельных вычислениях, а перцептрон полностью соответствовал принципам таких вычислений. По большому счёту, Минский показал преимущество последовательных вычислений перед параллельным в определённых классах задач, связанных с инвариантным представлением. Его критику можно разделить на три темы:</p>

<ol>
<li>Перцептроны имеют ограничения в задачах, связанных с <i>инвариантным представлением</i> образов, то есть независимым от их положения на сенсорном поле и относительно других фигур. Такие задачи возникают, например, если нам требуется построить машину для чтения печатных букв или цифр так, чтобы эта машина могла распознавать их независимо от положения на странице (то есть чтобы на решение машины не оказывали влияния перенос, поворот, растяжение-сжатие символов); или если нам нужно определить из скольких частей состоит фигура; или находятся ли две фигуры рядом или нет. Минским было доказано, что этот тип задач невозможно полноценно решить с помощью параллельных вычислений, в том числе — перцептрона.</li>
<li>Перцептроны не имеют функционального преимущества над аналитическими методами (например, статистическими) в задачах, связанных с прогнозированием. Тем не менее, в некоторых случаях они представляют более простой и производительный метод анализа данных.</li>
<li>Было показано, что некоторые задачи в принципе могут быть решены перцептроном, но могут потребовать нереально большого времени или нереально большой памяти.</li></ol>

<p>Книга Минского и Паперта существенно повлияла на пути развития науки об искусственном интеллекте, так как переместила научный интерес и субсидии правительственных организаций США на другое направление исследований — символьный подход в ИИ.</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D1.86.D0.B5.D0.BF.D1.82.D1.80.D0.BE.D0.BD.D0.BE.D0.B2">Применение перцептронов</span></h3>
<p>Здесь будут показаны только основы практического применения перцептрона на двух различных задачах. Задача <i>прогнозирования</i> (и эквивалентная ей задача <i>распознавания образов</i>) требует высокой точности, а задача <i>управления агентами</i> — высокой скорости обучения. Поэтому, рассматривая эти задачи, можно полноценно ознакомиться с возможностями перцептрона, однако этим далеко не исчерпываются варианты его использования.</p>
<p>В практических задачах от перцептрона потребуется возможность выбора более чем из двух вариантов, а значит, на выходе у него должно находиться более одного R-элемента. Как показано Розенблаттом, характеристики таких систем не отличаются существенно от характеристик элементарного перцептрона.</p>
<h4><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B3.D0.BD.D0.BE.D0.B7.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B8_.D1.80.D0.B0.D1.81.D0.BF.D0.BE.D0.B7.D0.BD.D0.B0.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2">Прогнозирование и распознавание образов</span></h4>
<p>обучающегося агента]] со средой. Важной частью такой системы являются обратные связи.
В этих задачах от перцептрона требуется установить принадлежность объекта к какому-либо классу по его параметрам (например, по внешнему виду, форме, силуэту). Причём, точность распознавания будет во многом зависеть от представления выходных реакций перцептрона. Здесь возможны три типа кодирования: конфигурационное, позиционное, и гибридное. Позиционное кодирование, когда каждому классу соответствует свой R-элемент, даёт более точные результаты, чем другие виды. Такой тип использован, например, в работе Э. Куссуль и др. «Перцептроны Розенблатта для распознавания рукописных цифр». Однако оно неприменимо в тех случаях, когда число классов значительно, например, несколько сотен. В таких случаях можно применять гибридное конфигурационно-позиционное кодирование, как это было сделано в работе С. Яковлева «Система распознавания движущихся объектов на базе искусственных нейронных сетей».</p>
<h4><span class="mw-headline" id=".D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B0.D0.B3.D0.B5.D0.BD.D1.82.D0.B0.D0.BC.D0.B8">Управление агентами</span></h4>
<p>В искусственном интеллекте часто рассматриваются обучающиеся (адаптирующиеся к окружающей среде) агенты. При этом в условиях неопределённости становится важным анализировать не только текущую информацию, но и общий контекст ситуации, в которую попал агент, поэтому здесь примененяются перцептроны с обратной связью. Кроме того, в некоторых задачах становится важным повышение скорости обучения перцептрона, например, с помощью моделирования рефрактерности.</p>
<p>После периода, известного как «Зима искусственного интеллекта», интерес к кибернетическим моделям возродился в 1980-х годах, так как сторонники символьного подхода в ИИ так и не смогли подобраться к решению вопросов о «Понимании» и «Значении», из-за чего машинный перевод и техническое распознавание образов до сих пор обладает неустранимыми недостатками. Сам Минский публично выразил сожаление, что его выступление нанесло урон концепции перцептронов, хотя книга лишь показывала недостатки отдельно взятого устройства и некоторых его вариаций. Но в основном ИИ стал синонимом символьного подхода, который выражался в составлении все более сложных программ для компьютеров, моделирующих сложную деятельность человеческого мозга.</p>
<h2><span class="mw-headline" id=".D0.A1.D0.BC._.D1.82.D0.B0.D0.BA.D0.B6.D0.B5">См. также</span></h2>

<ul>
<li>Биокомпьютинг</li>
<li>Байесовская сеть доверия</li>
<li>Когнитрон</li>
<li>История искусственного интеллекта</li>
<li>Паттерн (психология)</li></ul>

<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F">Примечания</span></h2>


<h2><span class="mw-headline" id=".D0.98.D1.81.D1.82.D0.BE.D1.87.D0.BD.D0.B8.D0.BA.D0.B8">Источники</span></h2>


<h2><span class="mw-headline" id=".D0.9B.D0.B8.D1.82.D0.B5.D1.80.D0.B0.D1.82.D1.83.D1.80.D0.B0">Литература</span></h2>

<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li></ul>

<h2><span class="mw-headline" id=".D0.A1.D1.81.D1.8B.D0.BB.D0.BA.D0.B8">Ссылки</span></h2>

<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li></ul>



<p>
Категория:Аналоговые компьютеры</p>
<p><a href="http://ar.wikipedia.org/wiki/%D8%A8%D9%8A%D8%B1%D8%B3%D9%8A%D8%A8%D8%AA%D8%B1%D9%88%D9%86">ar:??????????</a>
<a href="http://ca.wikipedia.org/wiki/Perceptr%C3%B3">ca:Perceptr?</a>
<a href="http://cs.wikipedia.org/wiki/Perceptron">cs:Perceptron</a>
<a href="http://de.wikipedia.org/wiki/Perzeptron">de:Perzeptron</a>
<a href="http://el.wikipedia.org/wiki/Perceptron">el:Perceptron</a>
<a href="http://en.wikipedia.org/wiki/Perceptron">en:Perceptron</a>
<a href="http://es.wikipedia.org/wiki/Perceptr%C3%B3n">es:Perceptr?n</a>
<a href="http://fa.wikipedia.org/wiki/%D9%BE%D8%B1%D8%B3%D9%BE%D8%AA%D8%B1%D9%88%D9%86">fa:????????</a>
<a href="http://fr.wikipedia.org/wiki/Perceptron">fr:Perceptron</a>
<a href="http://he.wikipedia.org/wiki/%D7%A4%D7%A8%D7%A1%D7%A4%D7%98%D7%A8%D7%95%D7%9F">he:????????</a>
<a href="http://it.wikipedia.org/wiki/Percettrone">it:Percettrone</a>
<a href="http://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%82%BB%E3%83%97%E3%83%88%E3%83%AD%E3%83%B3">ja:???????</a>
<a href="http://ko.wikipedia.org/wiki/%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0">ko:????</a>
<a href="http://mk.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D1%86%D0%B5%D0%BF%D1%82%D1%80%D0%BE%D0%BD">mk:Перцептрон</a>
<a href="http://ne.wikipedia.org/wiki/%E0%A4%AA%E0%A5%8D%E0%A4%B0%E0%A4%B8%E0%A5%87%E0%A4%AA%E0%A5%8D%E0%A4%9F%E0%A5%8D%E0%A4%B0%E0%A5%8B%E0%A4%A8">ne:????????????</a>
<a href="http://nl.wikipedia.org/wiki/Perceptron">nl:Perceptron</a>
<a href="http://pl.wikipedia.org/wiki/Perceptron">pl:Perceptron</a>
<a href="http://pt.wikipedia.org/wiki/Perceptron">pt:Perceptron</a>
<a href="http://sk.wikipedia.org/wiki/Perceptr%C3%B3n">sk:Perceptr?n</a>
<a href="http://sl.wikipedia.org/wiki/Perceptron">sl:Perceptron</a>
<a href="http://sv.wikipedia.org/wiki/Perceptron">sv:Perceptron</a>
<a href="http://th.wikipedia.org/wiki/%E0%B9%80%E0%B8%9E%E0%B8%AD%E0%B8%A3%E0%B9%8C%E0%B9%80%E0%B8%8B%E0%B8%9B%E0%B8%95%E0%B8%A3%E0%B8%AD%E0%B8%99">th:????????????</a>
<a href="http://uk.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D1%86%D0%B5%D0%BF%D1%82%D1%80%D0%BE%D0%BD">uk:Перцептрон</a>
<a href="http://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8">zh:???</a></p>
</html>